<head>
<meta charset="UTF-8">
<title>CTOR Tournament — Browser Edition</title>

<style>
/* ===== Общий стиль страницы ===== */
body {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 0;
  background: #f5f5dc;
  font-family: sans-serif;
  padding: 20px;
}

/* ===== Панель управления ===== */
#controls {
  margin: 20px 0;
  text-align: center;
}

button, select, input[type="file"] {
  margin: 4px;
  padding: 6px 10px;
  font-size: 13px;
  cursor: pointer;
}

#status {
  margin: 8px 0;
  padding: 8px;
  background: #e8f4fd;
  border-radius: 5px;
  font-size: 13px;
  max-width: 600px;
}

/* ===== Таблица ботов (300 px, со скроллом) ===== */
#botTableContainer {
  width: 300px;
  max-height: 200px;
  overflow-y: auto;
  border: 1px solid #aaa;
  background: #faf7e8;
  margin-top: 10px;
  border-radius: 6px;
}

#botTable {
  width: 100%;
  border-collapse: collapse;
  font-size: 13px;
}

#botTable th, #botTable td {
  border-bottom: 1px solid #ccc;
  padding: 4px 6px;
  text-align: left;
}

#botTable tr:nth-child(even) {
  background: #f3efdd;
}

/* ===== Поле CTOR (твоя графика) ===== */
table#board {
  border-collapse: collapse;
  margin: 20px auto;
  cursor: pointer;
}

#board td {
  width: 30px;
  height: 30px;
  border: 1px solid #666;
  text-align: center;
  vertical-align: middle;
  background: #f7f3de;
  padding: 0;
  position: relative;
}

td.frame {
  background: #e5dfc2;
}

td.inner {}

/* ===== Фишки ===== */
td.black::after,
td.white::after {
  content: '';
  position: absolute;
  inset: 3px;
  border-radius: 50%;
  box-shadow:
    0 1px 1px rgba(0,0,0,0.8),
    inset 0 2px 4px rgba(255,255,255,0.4),
    inset 0 -2px 4px rgba(0,0,0,0.4);
}

td.black::after {
  background: radial-gradient(circle at 30% 20%, #666, #111 70%, #000);
}

td.white::after {
  background: radial-gradient(circle at 30% 20%, #ffffff, #d0d0d0 70%, #aaaaaa);
}

/* ===== Подсветки ===== */
td.move-source::after {
  outline: 2px solid orange;
  outline-offset: 0;
}

td.replace-selected::after {
  outline: 2px solid gold;
  outline-offset: 0;
}
</style>
</head>
<body>

<!-- ===== Панель управления ===== -->
<div id="controls">

  <!-- Выбор ботов -->
  <div>
    <label>Bot R:
      <select id="botR"></select>
    </label>

    <label>Bot B:
      <select id="botB"></select>
    </label>
  </div>

  <!-- Загрузка пользовательского бота -->
  <div>
    <input type="file" id="botUpload" accept=".js">
    <button id="uploadBtn">Upload Bot</button>
  </div>

  <!-- Кнопки управления матчем -->
  <div style="margin-top:10px;">
    <button id="startBtn">Start Match</button>
    <button id="stepBtn">Next Move</button>
    <button id="autoBtn">Auto Play</button>
    <button id="stopBtn">Stop</button>
  </div>
<div style="margin-top:10px;">
  <label>Delay: </label>
  <input id="delayInput" type="text" value="0.50" style="width:60px;"> sec
</div>

<!-- ===== Таблица всех ботов ===== -->
<h3>Available Bots</h3>
<div id="botTableContainer">
  <table id="botTable">
    <thead>
      <tr>
        <th>Name</th>
        <th>Source</th>
      </tr>
    </thead>
    <tbody id="botTableBody">
      <!-- строки добавляются динамически -->
    </tbody>
  </table>
</div>

<!-- ===== Статус ===== -->
<div id="status">Status: ready.</div>

<!-- ===== Счёт ===== -->
<div id="scoreBox">
  Score: R = <span id="scoreR">0</span> |
  B = <span id="scoreB">0</span>
</div>

<!-- ===== Поле CTOR ===== -->
<table id="board"></table>
<script>
/* ============================================================
   CTOR-MINIMAL v3 — GAME ENGINE (Variant A1)
   - 10×10 toroidal board
   - Up to 2 PUT per turn
   - Up to 2 MOVE per turn
   - autoEat after each operation
   - Turn ends when limits exhausted
   ============================================================ */

class CTORGame {
  constructor() {
    this.N = 10;
    this.reset();
  }

  reset() {
    this.board = this.makeEmptyBoard();
    this.current = 'R';        // R starts
    this.turn = 1;
    this.finished = false;
    this.winner = null;

    this.opUsed = { put: 0, move: 0 };
  }

  makeEmptyBoard() {
    const b = [];
    for (let i = 0; i < this.N; i++) {
      b[i] = [];
      for (let j = 0; j < this.N; j++) b[i][j] = '.';
    }
    return b;
  }

  cloneBoard() {
    return this.board.map(row => row.slice());
  }

  /* ============================================================
     LEGAL MOVES
     ============================================================ */

  getLegalMoves(player) {
    if (this.finished) return [];

    const moves = [];

    // ----- PUT -----
    if (this.opUsed.put < 2) {
      for (let i = 0; i < this.N; i++) {
        for (let j = 0; j < this.N; j++) {
          if (this.board[i][j] === '.') {
            moves.push({ type: "put", i, j });
          }
        }
      }
    }

    // ----- MOVE -----
    if (this.opUsed.move < 2) {
      for (let i = 0; i < this.N; i++) {
        for (let j = 0; j < this.N; j++) {
          if (this.board[i][j] === player) {
            const neigh = this.getOrthNeighbors(i, j);
            for (const [ni, nj] of neigh) {
              if (this.board[ni][nj] === '.') {
                moves.push({
                  type: "move",
                  from: [i, j],
                  to: [ni, nj]
                });
              }
            }
          }
        }
      }
    }

    return moves;
  }

  /* ============================================================
     APPLY MOVE
     ============================================================ */

  applyMove(move) {
    if (this.finished) return;

    if (move.type === "put") {
      this.board[move.i][move.j] = this.current;
      this.opUsed.put++;
    }

    else if (move.type === "move") {
      const [i1, j1] = move.from;
      const [i2, j2] = move.to;
      this.board[i1][j1] = '.';
      this.board[i2][j2] = this.current;
      this.opUsed.move++;
    }

    // autoEat after each operation
    this.autoEat();

    // check if turn ends
    if (this.opUsed.put >= 2 && this.opUsed.move >= 2) {
      this.endTurn();
    }
  }

  /* ============================================================
     END TURN
     ============================================================ */

  endTurn() {
    this.opUsed = { put: 0, move: 0 };
    this.current = (this.current === 'R') ? 'B' : 'R';
    this.turn++;

    this.checkWinner();
  }

  /* ============================================================
     AUTO-EAT (Toroidal 3×3 neighborhood)
     ============================================================ */

  autoEat() {
  let changed = true;

  while (changed) {
    changed = false;

    for (let i = 0; i < this.N; i++) {
      for (let j = 0; j < this.N; j++) {

        const cell = this.board[i][j];

        // проверяем только фишки противника
        if (cell !== '.' && cell !== this.current) {

          // ВАЖНО: пересчитываем расширенную доску перед каждой проверкой
          const ext = this.buildExtendedBoard();

          const cnt = this.countNeighbors(i, j, this.current, ext);

          if (cnt >= 5) {
            this.board[i][j] = this.current;
            changed = true;
          }
        }
      }
    }
  }
}

  /* ============================================================
     EXTENDED BOARD FOR TOROID
     ============================================================ */

  buildExtendedBoard() {
    const N = this.N;
    const VS = N + 2;
    const ext = Array.from({ length: VS }, () => Array(VS).fill('.'));

    // center
    for (let i = 0; i < N; i++)
      for (let j = 0; j < N; j++)
        ext[i+1][j+1] = this.board[i][j];

    // top/bottom
    for (let j = 1; j <= N; j++) {
      ext[0][j]   = this.board[N-1][j-1];
      ext[N+1][j] = this.board[0][j-1];
    }

    // left/right
    for (let i = 1; i <= N; i++) {
      ext[i][0]   = this.board[i-1][N-1];
      ext[i][N+1] = this.board[i-1][0];
    }

    // corners
    ext[0][0]       = this.board[N-1][N-1];
    ext[0][N+1]     = this.board[N-1][0];
    ext[N+1][0]     = this.board[0][N-1];
    ext[N+1][N+1]   = this.board[0][0];

    return ext;
  }

  countNeighbors(i, j, player, ext) {
    const ei = i + 1;
    const ej = j + 1;
    let count = 0;

    for (let di = -1; di <= 1; di++) {
      for (let dj = -1; dj <= 1; dj++) {
        if (di === 0 && dj === 0) continue;
        if (ext[ei + di][ej + dj] === player) count++;
      }
    }
    return count;
  }

  /* ============================================================
     ORTHOGONAL NEIGHBORS (TOROID)
     ============================================================ */

  getOrthNeighbors(i, j) {
    const N = this.N;
    return [
      [(i - 1 + N) % N, j],
      [(i + 1) % N, j],
      [i, (j - 1 + N) % N],
      [i, (j + 1) % N]
    ];
  }

  /* ============================================================
     CHECK WINNER
     ============================================================ */

  checkWinner() {
    const movesR = this.getLegalMoves('R');
    const movesB = this.getLegalMoves('B');

    if (movesR.length === 0 && movesB.length === 0) {
      this.finished = true;
      const [r, b] = this.getScore();
      this.winner = (r > b) ? 'R' : (b > r) ? 'B' : 'draw';
    }
  }

  /* ============================================================
     SCORE
     ============================================================ */

  getScore() {
    let r = 0, b = 0;
    for (let i = 0; i < this.N; i++) {
      for (let j = 0; j < this.N; j++) {
        if (this.board[i][j] === 'R') r++;
        else if (this.board[i][j] === 'B') b++;
      }
    }
    return [r, b];
  }
}
</script>
<script>
/* ============================================================
   BUILT-IN BOTS
   ============================================================ */

const Bots = {
  random(board, player) {
    const moves = game.getLegalMoves(player);
    if (moves.length === 0) return null;
    return moves[Math.floor(Math.random() * moves.length)];
  },

  greedy(board, player) {
    const moves = game.getLegalMoves(player);
    if (moves.length === 0) return null;

    let best = null;
    let bestScore = -Infinity;

    for (const m of moves) {
      const tmp = board.map(r => r.slice());
      applyMoveToBoard(tmp, m, player);
      const score = evaluateBoard(tmp, player);
      if (score > bestScore) {
        bestScore = score;
        best = m;
      }
    }
    return best;
  }
};

/* Track bot sources */
const botSources = {
  random: "built-in",
  greedy: "built-in"
};

/* Helper for greedy bot */
function applyMoveToBoard(b, move, player) {
  if (move.type === "put") {
    b[move.i][move.j] = player;
  } else if (move.type === "move") {
    const [i1, j1] = move.from;
    const [i2, j2] = move.to;
    b[i1][j1] = '.';
    b[i2][j2] = player;
  }
}

function evaluateBoard(b, player) {
  let score = 0;
  for (let i = 0; i < b.length; i++)
    for (let j = 0; j < b.length; j++)
      if (b[i][j] === player) score++;
  return score;
}

/* ============================================================
   BOT UPLOAD
   ============================================================ */

document.getElementById("uploadBtn").onclick = () => {
  const file = document.getElementById("botUpload").files[0];
  if (!file) return;

  const name = file.name.replace(".js", "");

  const reader = new FileReader();
  reader.onload = (e) => {
    const code = e.target.result;

    Bots[name] = new Function(
      "board", "player",
      code + "; return bot(board, player);"
    );

    botSources[name] = "uploaded (" + new Date().toLocaleTimeString() + ")";
    addBotToSelect(name);
    refreshBotTable();
  };
  reader.readAsText(file);
};

function addBotToSelect(name) {
  const r = document.getElementById("botR");
  const b = document.getElementById("botB");

  const opt1 = document.createElement("option");
  opt1.value = name;
  opt1.textContent = name;

  const opt2 = opt1.cloneNode(true);

  r.appendChild(opt1);
  b.appendChild(opt2);
}

function refreshBotTable() {
  const body = document.getElementById("botTableBody");
  body.innerHTML = "";

  for (const name in Bots) {
    const tr = document.createElement("tr");

    const tdName = document.createElement("td");
    tdName.textContent = name;

    const tdSource = document.createElement("td");
    tdSource.textContent = botSources[name] || "unknown";

    tr.appendChild(tdName);
    tr.appendChild(tdSource);
    body.appendChild(tr);
  }
}
/* ============================================================
   GAME + VISUALIZATION
   ============================================================ */

let game = new CTORGame();
let autoTimer = null;

/* Create board table (N × N) */
function createBoardTable() {
  const table = document.getElementById("board");
  table.innerHTML = "";

  const N = game.N;  // 10

  for (let i = 0; i < N; i++) {
    const tr = document.createElement("tr");
    for (let j = 0; j < N; j++) {
      const td = document.createElement("td");
      td.dataset.i = i;
      td.dataset.j = j;
      td.classList.add("inner");
      tr.appendChild(td);
    }
    table.appendChild(tr);
  }
}

/* Update board view (only 10×10) */
function updateBoardView() {
  const N = game.N;

  const tds = document.querySelectorAll("#board td");
  tds.forEach(td => {
    const i = parseInt(td.dataset.i, 10);
    const j = parseInt(td.dataset.j, 10);

    td.classList.remove("black", "white");

    const val = game.board[i][j];
    if (val === 'R') td.classList.add("black");
    if (val === 'B') td.classList.add("white");
  });

  const [r, b] = game.getScore();
  document.getElementById("scoreR").textContent = r;
  document.getElementById("scoreB").textContent = b;

  document.getElementById("status").textContent =
    game.finished
      ? `Game finished. Winner: ${game.winner}`
      : `Turn ${game.turn} — Player ${game.current}`;
}

/* Step button */
document.getElementById("stepBtn").onclick = stepOneMove;

/* Auto Play button with delay */
document.getElementById("autoBtn").onclick = () => {
  if (autoTimer) return;

  const delay = parseFloat(document.getElementById("delayInput").value) * 1000;
  autoTimer = setInterval(stepOneMove, isNaN(delay) ? 500 : delay);
};

/* Stop button */
document.getElementById("stopBtn").onclick = () => {
  clearInterval(autoTimer);
  autoTimer = null;
};

/* ============================================================
   MATCH CONTROL
   ============================================================ */

document.getElementById("startBtn").onclick = () => {
  game = new CTORGame();
  createBoardTable();
  updateBoardView();
};

document.getElementById("stepBtn").onclick = stepOneMove;

document.getElementById("autoBtn").onclick = () => {
  if (autoTimer) return;
  const delay = parseFloat(document.getElementById("delayInput").value) * 1000; 
  autoTimer = setInterval(stepOneMove, isNaN(delay) ? 500 : delay);
};

document.getElementById("stopBtn").onclick = () => {
  clearInterval(autoTimer);
  autoTimer = null;
};

function stepOneMove() {
  if (game.finished) {
    clearInterval(autoTimer);
    autoTimer = null;
    updateBoardView();
    return;
  }

  const player = game.current;
  const botName = (player === "R")
    ? document.getElementById("botR").value
    : document.getElementById("botB").value;

  const move = Bots[botName](game.cloneBoard(), player);

  if (!move) {
    game.endTurn();
    updateBoardView();
    return;
  }

  game.applyMove(move);
  updateBoardView();
}

/* ============================================================
   INITIALIZATION
   ============================================================ */

function init() {
  // Fill selects with built-in bots
  addBotToSelect("random");
  addBotToSelect("greedy");

  refreshBotTable();
  createBoardTable();
  updateBoardView();
}

init();
</script>
</body> 
</html>
